/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package frame;

import admintools.CSVOperate;
import admintools.DBImportAction;
import admintools.JDBCConnection;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URL;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListModel;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.ListSelectionModel;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author lera
 */
public class OperateFrame extends javax.swing.JFrame {
    private JDBCConnection connection;
    private int idOperation;// идентификатор операций (импорт, экспорт, обновление)
    private DBOperation dbOperate;
    private ConnectOptions connOptions;
    private final String defaultTitle = "Admin Tools for database operations: ";
    private admintools.DBOperation Operations;
    
    /**
     * Creates new form OperateFrame
     */
    public OperateFrame() {
        initComponents();
        idOperation = 0;
//        setFrameTitle();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        OptionDialog = new javax.swing.JDialog();
        chkHeader = new javax.swing.JCheckBox();
        jPanel1 = new javax.swing.JPanel();
        CommaRadioBtn = new javax.swing.JRadioButton();
        CommaPointRadioBtn = new javax.swing.JRadioButton();
        TwinPointRadioBtn = new javax.swing.JRadioButton();
        YesButton = new javax.swing.JButton();
        buttonGroup1 = new javax.swing.ButtonGroup();
        jLabel1 = new javax.swing.JLabel();
        jToolBar1 = new javax.swing.JToolBar();
        btnOpenFile = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        lstTableName = new javax.swing.JList();
        jScrollPane2 = new javax.swing.JScrollPane();
        lstTargetList = new javax.swing.JList();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        btnPreviouse = new javax.swing.JButton();
        btnNext = new javax.swing.JButton();
        OKButton = new javax.swing.JButton();
        btnSendTo = new javax.swing.JButton();
        jScrollPane4 = new javax.swing.JScrollPane();
        txtStep = new javax.swing.JTextArea();
        OperateProgressBar = new javax.swing.JProgressBar();
        jMenuBar1 = new javax.swing.JMenuBar();
        mnuFile = new javax.swing.JMenu();
        mnuFileConnection = new javax.swing.JMenu();
        mnuConnectProperties = new javax.swing.JMenuItem();
        mnuConnectParameters = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        mnuFileExit = new javax.swing.JMenuItem();
        mnuData = new javax.swing.JMenu();
        mnuDataImport = new javax.swing.JMenuItem();
        mnuDataExport = new javax.swing.JMenuItem();
        mnuDataUpdate = new javax.swing.JMenuItem();

        OptionDialog.setModal(true);

        chkHeader.setSelected(true);
        chkHeader.setText("В первой строке заголовки столбцов");

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Разделитель полей"));

        buttonGroup1.add(CommaRadioBtn);
        CommaRadioBtn.setText("Запятая");

        buttonGroup1.add(CommaPointRadioBtn);
        CommaPointRadioBtn.setSelected(true);
        CommaPointRadioBtn.setText("Точка с запятой");

        buttonGroup1.add(TwinPointRadioBtn);
        TwinPointRadioBtn.setText("Двоеточие");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(CommaRadioBtn)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(CommaPointRadioBtn)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(TwinPointRadioBtn)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(CommaRadioBtn)
                    .addComponent(CommaPointRadioBtn)
                    .addComponent(TwinPointRadioBtn))
                .addGap(26, 26, 26))
        );

        YesButton.setText("ОК");
        YesButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                YesButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout OptionDialogLayout = new javax.swing.GroupLayout(OptionDialog.getContentPane());
        OptionDialog.getContentPane().setLayout(OptionDialogLayout);
        OptionDialogLayout.setHorizontalGroup(
            OptionDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, OptionDialogLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(OptionDialogLayout.createSequentialGroup()
                .addGroup(OptionDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(OptionDialogLayout.createSequentialGroup()
                        .addGap(123, 123, 123)
                        .addComponent(YesButton))
                    .addGroup(OptionDialogLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(chkHeader)))
                .addGap(0, 0, Short.MAX_VALUE))
        );
        OptionDialogLayout.setVerticalGroup(
            OptionDialogLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(OptionDialogLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(chkHeader)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(YesButton)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentHidden(java.awt.event.ComponentEvent evt) {
                formComponentHidden(evt);
            }
            public void componentShown(java.awt.event.ComponentEvent evt) {
                formComponentShown(evt);
            }
        });

        jLabel1.setText("jLabel1");

        jToolBar1.setRollover(true);

        btnOpenFile.setIcon(new javax.swing.ImageIcon(getClass().getResource("/image/OpenFile.png"))); // NOI18N
        btnOpenFile.setToolTipText("открыть файл");
        btnOpenFile.setFocusable(false);
        btnOpenFile.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        btnOpenFile.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
        btnOpenFile.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        btnOpenFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnOpenFileActionPerformed(evt);
            }
        });
        jToolBar1.add(btnOpenFile);

        jButton1.setText("jButton1");
        jButton1.setFocusable(false);
        jButton1.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton1.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar1.add(jButton1);

        jButton2.setText("jButton2");
        jButton2.setFocusable(false);
        jButton2.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton2.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar1.add(jButton2);

        jLabel2.setText("jLabel2");

        jScrollPane1.setViewportView(lstTableName);

        lstTargetList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPane2.setViewportView(lstTargetList);

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jTable1.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
        jTable1.setCellSelectionEnabled(true);
        jTable1.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_INTERVAL_SELECTION);
        jScrollPane3.setViewportView(jTable1);

        btnPreviouse.setIcon(new javax.swing.ImageIcon(getClass().getResource("/image/NavBack.png"))); // NOI18N

        btnNext.setIcon(new javax.swing.ImageIcon(getClass().getResource("/image/NavForward.png"))); // NOI18N

        OKButton.setText("Отмена");

        btnSendTo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/image/NavForward.png"))); // NOI18N

        jScrollPane4.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        txtStep.setBackground(new java.awt.Color(212, 208, 200));
        txtStep.setColumns(20);
        txtStep.setFont(new java.awt.Font("Tahoma", 0, 11)); // NOI18N
        txtStep.setLineWrap(true);
        txtStep.setRows(5);
        txtStep.setWrapStyleWord(true);
        txtStep.setFocusable(false);
        jScrollPane4.setViewportView(txtStep);

        OperateProgressBar.setStringPainted(true);

        mnuFile.setText("Файл");

        mnuFileConnection.setIcon(new javax.swing.ImageIcon(getClass().getResource("/image/base.png"))); // NOI18N
        mnuFileConnection.setText("Соединение");

        mnuConnectProperties.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        mnuConnectProperties.setIcon(new javax.swing.ImageIcon(getClass().getResource("/image/CommentHS.png"))); // NOI18N
        mnuConnectProperties.setText("Выбрать файл свойств");
        mnuConnectProperties.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuConnectPropertiesActionPerformed(evt);
            }
        });
        mnuFileConnection.add(mnuConnectProperties);

        mnuConnectParameters.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_P, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        mnuConnectParameters.setIcon(new javax.swing.ImageIcon(getClass().getResource("/image/info.png"))); // NOI18N
        mnuConnectParameters.setText("Окно ввода параметров");
        mnuConnectParameters.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuConnectParametersActionPerformed(evt);
            }
        });
        mnuFileConnection.add(mnuConnectParameters);

        mnuFile.add(mnuFileConnection);

        jMenuItem2.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem2.setIcon(new javax.swing.ImageIcon(getClass().getResource("/image/OpenFile.png"))); // NOI18N
        jMenuItem2.setText("Открыть");
        mnuFile.add(jMenuItem2);
        mnuFile.add(jSeparator1);

        mnuFileExit.setIcon(new javax.swing.ImageIcon(getClass().getResource("/image/exit.png"))); // NOI18N
        mnuFileExit.setText("Выход");
        mnuFileExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuFileExitActionPerformed(evt);
            }
        });
        mnuFile.add(mnuFileExit);

        jMenuBar1.add(mnuFile);

        mnuData.setText("Данные");
        mnuData.setEnabled(false);

        mnuDataImport.setText("Импорт");
        mnuDataImport.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuDataImportActionPerformed(evt);
            }
        });
        mnuData.add(mnuDataImport);

        mnuDataExport.setText("Экспорт");
        mnuDataExport.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuDataExportActionPerformed(evt);
            }
        });
        mnuData.add(mnuDataExport);

        mnuDataUpdate.setText("Обновление даннчх");
        mnuDataUpdate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuDataUpdateActionPerformed(evt);
            }
        });
        mnuData.add(mnuDataUpdate);

        jMenuBar1.add(mnuData);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jToolBar1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 172, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(btnSendTo, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel2)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 170, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(btnPreviouse)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnNext)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(OKButton))
                    .addComponent(jScrollPane4)
                    .addComponent(OperateProgressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(65, Short.MAX_VALUE))
            .addComponent(jScrollPane3)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(13, 13, 13)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(OperateProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(11, 11, 11)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(btnPreviouse)
                            .addComponent(btnNext)
                            .addComponent(OKButton)))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jLabel2)
                                .addComponent(jLabel1))
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                            .addComponent(btnSendTo)
                            .addGap(51, 51, 51))))
                .addGap(8, 8, 8)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 247, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown
        OperateProgressBar.setValue(0);
        
        // задаём заголовок фрейма
        setTitle(defaultTitle);
        
        // задаём значок для формы
        URL url;
        url = OperateFrame.class.getClassLoader().getResource("image/base.png");
        setIconImage(new ImageIcon(url).getImage());
        
//        setIdOperation();// задаём тип выполняемой опереции
        this.setLocationRelativeTo(null);// располагаем форму по середине экрана
        try {
            dbOperate = new DBOperation();
            btnPreviouse.doClick();
            
        } catch(java.lang.Exception ex){
        }
    }//GEN-LAST:event_formComponentShown

    private void formComponentHidden(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentHidden
        // закрываем соединение с базой перед выходом
        closeConnection();
        System.exit(0);
    }//GEN-LAST:event_formComponentHidden

    private void btnOpenFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnOpenFileActionPerformed
        // отображаем окно выбора файла
        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new File("."));
        chooser.setMultiSelectionEnabled(false);// множественныый выбор запрещён
        // фильтр файлов по формату
        FileFilter filter = new FileFilter() {

            @Override
            public boolean accept(File f) {
                return f.getName().toLowerCase().endsWith(".csv") || 
                        f.getName().toLowerCase().endsWith(".txt") || 
                        f.isDirectory();
            }

            @Override
            public String getDescription() {
                return "Текстовые файлы с разделителями (*.csv,*.txt)";
            }
        };
        chooser.setFileFilter(filter);// устанавливаем фильтр для окна выбора файла
        int result = chooser.showOpenDialog(this);
        
        // если пользователь выбрал файл, то отображаем его название в заголовке
        if(result == JFileChooser.APPROVE_OPTION){
            // устанавливаем заголовок окна в ихсодное состояние
//            setFrameTitle();
            
            String name;
            try {
                name = chooser.getSelectedFile().getCanonicalPath();
                System.out.println("file - " + name);
                
//                setTitle(getTitle() + " : " + name);
                // окно дополнительных параметров файла
                OptionDialog.setSize(305, 147);
                OptionDialog.setLocationRelativeTo(this);
                OptionDialog.setVisible(true);
                String separator;
                // проверем выбор пользователя
                CSVOperate csvReader = new CSVOperate();
                csvReader.setFileName(name);
                csvReader.setHeader(chkHeader.isSelected());// есть ли заголовки
                if(CommaRadioBtn.isSelected()){
                    separator = ",";
                } else if(CommaPointRadioBtn.isSelected()){
                    separator = ";";
                } else {
                    separator = ":";
                }
                csvReader.setSeparator(separator);
                csvReader.readData();
                
                // получаем модель данных для таблицы
                DefaultTableModel model = new DefaultTableModel(csvReader.getData(), 
                        csvReader.getColumnName());
                jTable1.setModel(model);
                btnNext.doClick();
//                Operations.addListItem();// 
            } catch (IOException ex) {
                Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
            }
            
        }
    }//GEN-LAST:event_btnOpenFileActionPerformed

    private void YesButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_YesButtonActionPerformed
        // скрываем диалоговое окно дополнительных настроек
        OptionDialog.setVisible(false);
    }//GEN-LAST:event_YesButtonActionPerformed

    private void mnuFileExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuFileExitActionPerformed
        // TODO add your handling code here:
        closeConnection();// закрываем соединение с базой
        System.exit(0);// завершение работы
    }//GEN-LAST:event_mnuFileExitActionPerformed

    private void mnuDataImportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuDataImportActionPerformed
        // TODO add your handling code here:
        idOperation = 0;
        DBImportAction importAction = new DBImportAction(lstTableName, lstTargetList, txtStep, 
                jLabel1, jLabel2, jTable1, connection, btnSendTo, btnNext, btnPreviouse, OKButton);
        setFrameTitle();
    }//GEN-LAST:event_mnuDataImportActionPerformed

    private void mnuDataExportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuDataExportActionPerformed
        // TODO add your handling code here:
        idOperation = 1;
        setFrameTitle();
//        dbOperate.moveNext();
    }//GEN-LAST:event_mnuDataExportActionPerformed

    private void mnuDataUpdateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuDataUpdateActionPerformed
        // TODO add your handling code here:
        idOperation = 2;
        setFrameTitle();
//        dbOperate.moveNext();
    }//GEN-LAST:event_mnuDataUpdateActionPerformed

    /**
     * Открываем соединение с помощью выбранного файла свойств
     * @param evt 
     */
    private void mnuConnectPropertiesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuConnectPropertiesActionPerformed
        // отображаем диалоговое окно выбора файла
        JFileChooser chooser = new JFileChooser();
        chooser.setFileFilter(new FileNameExtensionFilter("Файлы свойств, .properties", "properties"));
        chooser.showDialog(this, "Open file");
        File f = chooser.getSelectedFile();// выбранный пользователем файл
        if(chooser.accept(f)){
            // если пользователь выбрал файл, то печатаем его имя
            System.out.println(chooser.getName(f));
            try {
                mnuData.setEnabled(openConnection(f));
            } catch (IOException | SQLException | ClassNotFoundException ex) {
                Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
            }
            
        }
            
    }//GEN-LAST:event_mnuConnectPropertiesActionPerformed

    private void mnuConnectParametersActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuConnectParametersActionPerformed
        // отображаем на экране окно ввода параметров подключения
        try {
            mnuData.setEnabled(openConnection(null));
        } catch (IOException | SQLException | ClassNotFoundException ex) {
            Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_mnuConnectParametersActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /*
         * Set the Nimbus look and feel
         */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /*
         * If Nimbus (introduced in Java SE 6) is not available, stay with the
         * default look and feel. For details see
         * http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(OperateFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /*
         * Create and display the form
         */
        java.awt.EventQueue.invokeLater(() -> {
            new OperateFrame().setVisible(true);
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JRadioButton CommaPointRadioBtn;
    private javax.swing.JRadioButton CommaRadioBtn;
    private javax.swing.JButton OKButton;
    private javax.swing.JProgressBar OperateProgressBar;
    private javax.swing.JDialog OptionDialog;
    private javax.swing.JRadioButton TwinPointRadioBtn;
    private javax.swing.JButton YesButton;
    private javax.swing.JButton btnNext;
    private javax.swing.JButton btnOpenFile;
    private javax.swing.JButton btnPreviouse;
    private javax.swing.JButton btnSendTo;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JCheckBox chkHeader;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JTable jTable1;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JList lstTableName;
    private javax.swing.JList lstTargetList;
    private javax.swing.JMenuItem mnuConnectParameters;
    private javax.swing.JMenuItem mnuConnectProperties;
    private javax.swing.JMenu mnuData;
    private javax.swing.JMenuItem mnuDataExport;
    private javax.swing.JMenuItem mnuDataImport;
    private javax.swing.JMenuItem mnuDataUpdate;
    private javax.swing.JMenu mnuFile;
    private javax.swing.JMenu mnuFileConnection;
    private javax.swing.JMenuItem mnuFileExit;
    private javax.swing.JTextArea txtStep;
    // End of variables declaration//GEN-END:variables

    /**
     * @param connection the connection to set
     */
    public void setConnection(JDBCConnection connection) {
        this.connection = connection;
    }
    
    /**
     * @param idOperation the idOperation to set
     */
    private void setIdOperation() {
        // название кнопки
        switch (idOperation) {
            case 0:
                OKButton.setText("Импорт");
                break;
            case 1:
                OKButton.setText("Экспорт");
                break;
            default:
                OKButton.setText("Обновить данные");
                break;
        }
        OKButton.setEnabled(false);// делаем её недоступной
    }
    
    /**
     * устанавливает заголовок окна
     */
    private void setFrameTitle(){
        String title;
        switch (idOperation) {
            case 0:
                title = defaultTitle + "Импорт данных";
                break;
            case 1:
                title = defaultTitle + "Экспорт данных";
                break;
            default:
                title = defaultTitle + "Обновление данных";
                break;
        }
        setTitle(title);
        setIdOperation();
    }
    
    /**
     * обеспечивает проведение операций импорта, экспорта и 
     * обновления базы данных
     */
    private class DBOperation {
        private Object[] table_Name;// массив с именами таблиц базы данных
        private Object[] column_Name;// массив с именами полей выбранной таблицы
        private int step = 0;// номер шага для выбранной операции с базой данных
        private String[] nameItem;// имена выбранных полей
        private String[] column;
        private final int importStep = 4;// количество шагов для операции импорта
        private final int exportStep = 3;// количество шагов для операции экспорта
        private final int updateStep = 5;// количество шагов для операции обновления
        private String table;// имя выбранной таблицы
        private DefaultListModel model;
        private String keyColumn;// имя ключевого поля для обновления данных

        public DBOperation(){
            executeOperation();
        }

        /**
        * устанавливает модель для списка
        */
        private void setListModel(JList list, Object[] nameArray){
            model = new DefaultListModel();
            model.clear();
    //        list.removeSelectionInterval(0, list.getModel().getSize());
            list.setModel(model);// очищаем список
            // если передан массив и он содержит данные
            if(nameArray != null && nameArray.length > 0){
                for (Object nameArray1 : nameArray) {
                    model.addElement(nameArray1.toString());
                }
                list.setModel(model);
            }
        }

        /**
        * следующий шаг выбранной операции
        */
        public void moveNext(){
            // перед перемещением на следующий шаг сравниваем его значение с 
            // заданным количеством шагов
            int count = 0;
            switch(idOperation){
                case 0:// импорт
                    count = importStep;
                    break;
                case 1:// экспорт
                    count = exportStep;
                    break;
                case 2:// обновление
                    count = updateStep;
                    break;
            }
            // увеличиваем шаг
            step++;
            if(step <= count){
                executeOperation();
            } else{
                step--;
                }
        }

        /**
        * предыдущий шаг выбранной операции
        */
        public void movePreviouse(){
            // уменьшаем шаг
            step--;
            if(step >= 0){

                executeOperation();
            } else{
                step = 0;
            }
        }

        /**
        * выполнение выбранного шага операции
        */
        private void executeOperation(){
            switch(idOperation){
                case 0:// импорт
                    importData();
                    break;
                case 1:// экспорт
                    exportData();
                    break;
                case 2:// обновление
                    updateData();
                    break;
            }
        }

        /**
        * операция импорта данных
        */
        private void importData(){
//            OKButton.setEnabled(false);
    //        OperateProgressBar.setVisible(false);
            OperateProgressBar.setValue(0);
            switch(step){
                case 0:// перечень таблиц базы данных
                    try {
                        getDBTableName();

                    } catch (SQLException ex) {
                        Logger.getLogger(DBOperation.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    txtStep.setText("Шаг 1: выберите таблицу для импорта данных");
                    jLabel1.setText("список таблиц");
                    jLabel2.setText("выбранная таблица");
                    break;
                case 1:
                    try {
                        // получаем перечень полей выбранной таблицы
                        getTableColumnName();

                    } catch (SQLException ex) {
                        Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    txtStep.setText("Шаг 2: выберите поля, в которые будут импортироваться" +
                            " данные");
                    jLabel1.setText("список полей");
                    jLabel2.setText("выбранные поля");
                    break;
                case 2:// перечень полей с данными
                    // заполняем список полями данных
                    nameItem = new String[jTable1.getColumnCount()];
                    for(int i = 0; i < nameItem.length; i++)
                        nameItem[i] = jTable1.getColumnName(i);
                    setListModel(lstTableName, nameItem);
                    setListModel(lstTargetList, column);
                    // запрещаем множественное выделение
                    lstTableName.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                    txtStep.setText("Шаг 3: выберите поля, из которых будут импортироваться" +
                            " данные, и соответствующие им поля из правого списка");
                    jLabel1.setText("список полей");
                    jLabel2.setText("выбранные поля");
                    break;
                case 3:
                    txtStep.setText("Шаг 4: нажмите Импорт для импорта данных");
                    OKButton.setEnabled(true);
                    break;
                case 4:
                    OperateProgressBar.setVisible(true);
                    txtStep.setText("Выполняется импорт данных. Ожидайте...");
                    int counter = importDataToDB();
                    String text = txtStep.getText() + "\n\r";
                    txtStep.setText(text + "Выполнен импорт данных в количестве " + counter);

                    break;
            }
        }

        /**
        * операция экспорта данных
        */
        private void exportData(){
            OKButton.setEnabled(false);
            OperateProgressBar.setVisible(false);
            OperateProgressBar.setValue(0);
            switch(step){
                case 0:
                    try {
                        getDBTableName();
                    } catch (SQLException ex) {
                        Logger.getLogger(DBOperation.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    txtStep.setText("Шаг 1: выберите таблицу для экспорта данных");
                    jLabel1.setText("список таблиц");
                    jLabel2.setText("выбранная таблица");
                    break;
                case 1:
                    try {
                        // получаем перечень полей выбранной таблицы
                        getTableColumnName();

                    } catch (SQLException ex) {
                        Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    txtStep.setText("Шаг 2: выберите поля, из которых будут " +
                            "экспортироваться данные");
                    jLabel1.setText("список полей");
                    jLabel2.setText("выбранные поля");
                    break;
                case 2:
                    // получаем данные для экспорта
                    getDataFromDBTable();
                    txtStep.setText("Шаг 3: нажмите Экспорт для экспорта данных");
                    OKButton.setEnabled(true);
                    break;
                case 3:
                    int count = 0;
                    OperateProgressBar.setVisible(true);
                    String text = txtStep.getText() + "\n\r";
                    txtStep.setText(text + "Выполнен экспорт данных в количестве " + count);
                    break;
            }
        }

        /**
        * операция обновления данных
        */
        private void updateData(){
            OKButton.setEnabled(false);
    //        OperateProgressBar.setVisible(false);
            OperateProgressBar.setValue(0);
            switch(step){
                case 0:
                    try {
                        getDBTableName();
                    } catch (SQLException ex) {
                        Logger.getLogger(DBOperation.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    jLabel1.setText("список таблиц");
                    jLabel2.setText("выбранная таблица");
                    txtStep.setText("Шаг 1: выберите таблицу для обновления данных");
                    break;
                case 1:
                    try {
                        // получаем перечень полей выбранной таблицы
                        getTableColumnName();

                    } catch (SQLException ex) {
                        Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    txtStep.setText("Шаг 2: выберите поля для обновления данных");
                    jLabel1.setText("список полей");
                    jLabel2.setText("выбранные поля");
                    break;
                case 2:
                    nameItem = new String[jTable1.getColumnCount()];
                    for(int i = 0; i < nameItem.length; i++)
                        nameItem[i] = jTable1.getColumnName(i);
                    setListModel(lstTargetList, nameItem);
                    txtStep.setText("Шаг 3: выберите ключевое поле для обновления" +
                            " данных из левого списка и соответствующее ему поле из" +
                            " правого списка");
                    jLabel1.setText("список полей");
                    jLabel2.setText("ключевое поле");
                    break;
                case 3:
                    nameItem = new String[jTable1.getColumnCount()];
                    for(int i = 0; i < nameItem.length; i++)
                        nameItem[i] = jTable1.getColumnName(i);
                    setListModel(lstTableName, nameItem);
                    setListModel(lstTargetList, column);
                    // запрещаем множественное выделение
                    lstTableName.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                    txtStep.setText("Шаг 4: выберите поля, из которых будут " +
                            "обновляться данные, и соответствующие " +
                            "им поля для обновления");
                    jLabel1.setText("список полей");
                    jLabel2.setText("выбранные поля");
                    break;
                case 4:
                    txtStep.setText("Шаг 5: нажмите Обновить для обновления данных");
                    OKButton.setEnabled(true);
                    break;
                case 5:
    //                OperateProgressBar.setVisible(true);
                    int update = updateDataDB();
                    String text = txtStep.getText() + "\n\r";
                    txtStep.setText( text + "Обновлены данные в количестве " + update);
                    break;

            }
        }

        /**
        * получение списка таблиц базы данных
        */
        private void getDBTableName() throws SQLException{
            table_Name = connection.getListTable();
            // устанавливаем модель для списка с именами теблиц
            setListModel(lstTableName, table_Name);
            // запрещаем множественное выделение
            lstTableName.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        }

        /**
        * получение списка полей выбранной таблицы
        */
        private void getTableColumnName() throws SQLException{
            column_Name = connection.getListColumnTable(table);
            setListModel(lstTableName, column_Name);
            // разрешаем множественное выделение
            lstTableName.setSelectionMode(
                    ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);// очищаем список для выбранных полей
            setListModel(lstTargetList, null);
        }

        /**
        *  добавляет элемент в список
        */
        public void addListItem(){
            switch(idOperation){
                case 0:// импорт
                    addListItemImport();
                    break;
                case 1:// экспорт
                    addListItemExport();
                    break;
                case 2:// обновление
                    addListitemUpdate();
                    break;
            }
        }

        private void addListItemImport(){
            model = new DefaultListModel();
            switch(step){
                case 0:// выбор таблицы

                    // добавляем в модель
                    model.addElement(lstTableName.getSelectedValue());
                    table = lstTableName.getSelectedValue().toString();

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);
                    break;
                case 1:// выбор полей
                    model = new DefaultListModel();
                    int[] index = lstTableName.getSelectedIndices();
                    column = new String[index.length];
                    // массив выделенных элементов
                    for(int i = 0; i < index.length; i++){
                        lstTableName.setSelectedIndex(index[i]);
                        model.addElement(lstTableName.getSelectedValue());
                        column[i] = lstTableName.getSelectedValue().toString();
                    }

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);

                    break;
                case 2:// сопоставление полей
                    // индекс выделенного элемента
                    int j = lstTargetList.getSelectedIndex();

                    Object value = lstTargetList.getSelectedValue() +
                            "-" +lstTableName.getSelectedValue();

                    model = new DefaultListModel();// переопределяем модель
                    for(int i = 0; 
                            i < lstTargetList.getModel().getSize(); i++){
                        lstTargetList.setSelectedIndex(i);
                        model.addElement(lstTargetList.getSelectedValue());
                    }

                    model.setElementAt(value, j);// новое значение

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);
                    break;
            }

        }

        private void addListItemExport(){
            model = new DefaultListModel();
            switch(step){
                case 0:// выбор таблицы

                    // добавляем в модель
                    model.addElement(lstTableName.getSelectedValue());
                    table = lstTableName.getSelectedValue().toString();

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);
                    break;
                case 1:// выбор полей
                    model = new DefaultListModel();
                    int[] index = lstTableName.getSelectedIndices();
                    column = new String[index.length];
                    // массив выделенных элементов
                    for(int i = 0; i < index.length; i++){
                        lstTableName.setSelectedIndex(index[i]);
                        model.addElement(lstTableName.getSelectedValue());
                        column[i] = lstTableName.getSelectedValue().toString();
                    }

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);

                    break;
            }
        }

        private void addListitemUpdate() {
            model = new DefaultListModel();
            switch(step){
                case 0:// выбор таблицы

                    // добавляем в модель
                    model.addElement(lstTableName.getSelectedValue());
                    table = lstTableName.getSelectedValue().toString();

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);
                    break;
                case 1:// выбор полей
                    model = new DefaultListModel();
                    int[] index = lstTableName.getSelectedIndices();
                    column = new String[index.length];
                    // массив выделенных элементов
                    for(int i = 0; i < index.length; i++){
                        lstTableName.setSelectedIndex(index[i]);
                        model.addElement(lstTableName.getSelectedValue());
                        column[i] = lstTableName.getSelectedValue().toString();
                    }

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);

                    break;
                case 2:// выбор ключевого поля
                    // добавляем в модель
                    model.addElement(lstTableName.getSelectedValue());

                    // первая часть - ключевое поле для обновления в таблице
                    // вторая часть - сопоставленное ему поле в массиве данных,
                    // значение которого будет использоваться для идентификации ключевого поля
                    keyColumn = lstTableName.getSelectedValue().toString() +
                            "-" + lstTargetList.getSelectedValue().toString();
                    System.out.println("keyColumn -" + keyColumn);
                    break;
                case 3:// сопоставление полей
                    // индекс выделенного элемента
                    int j = lstTargetList.getSelectedIndex();

                    Object value = lstTargetList.getSelectedValue() +
                            "-" +lstTableName.getSelectedValue();

                    model = new DefaultListModel();// переопределяем модель
                    for(int i = 0; 
                            i < lstTargetList.getModel().getSize(); i++){
                        lstTargetList.setSelectedIndex(i);
                        model.addElement(lstTargetList.getSelectedValue());
                    }

                    model.setElementAt(value, j);// новое значение

                    // устанавливаем модель для списка
                    lstTargetList.setModel(model);
                    break;
            }
        }

        private int importDataToDB(){
            // изменяем вид курсора на песочные часы
    //        setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
    //        ProgressDialog.setSize(370, 146);
    //        ProgressDialog.setLocation(getLocation().x, getLocation().y);
    //        ProgressDialog.setVisible(true);
            int rowCount = jTable1.getRowCount();

            // перебираем строки в правом списке полей,
            // используя символ-разделитель "-", и заполняем ими соответствующие массивы
            int row = lstTargetList.getModel().getSize();// количество элементов
            String[] leftCols = new String[row];// список выбранных полей таблицы БД
            String[] rightCols = new String[row];// список импортируемых полей
            int[] colIndex = new int[row];// индекы столбцов таблицы
            ArrayList error = new ArrayList();// массив ошибочных записей
            // заполняем массивы полей
            for(int i = 0; i < row; i++){
                lstTargetList.setSelectedIndex(i);// выделяем элемент списка
                int pos = lstTargetList.getSelectedValue().toString().indexOf("-");
                leftCols[i] = lstTargetList.getSelectedValue().toString().substring(0, pos);
                rightCols[i] = lstTargetList.getSelectedValue().toString().substring(pos + 1);
                // получаем индекс столбца по имени
                for(int j = 0; j < jTable1.getColumnCount(); j++){
                    if(rightCols[i].equals(jTable1.getColumnName(j))){
                        colIndex[i] = j;
    //                    System.out.println(colIndex[i]);
                        break;// прерываем цикл
                    }
                }
            }
            String sqlQuery;// строка-запрос на добавление записи
            String listfield = "";
            int retval = 0;
            for (String leftCol : leftCols) {
                listfield = listfield + leftCol + ",";
            }
            String fields = listfield.substring(0, listfield.length()-1);
            OperateProgressBar.setValue(0);
            for(int i = 0; i < rowCount; i++){
                // получаем список значений для вставки
                String listvalues = "";
                for(int j = 0; j < colIndex.length; j++){
    //                System.out.println(colIndex[j]);
                    String value = connection.getCellValue(leftCols[j],
                            jTable1.getValueAt(i, colIndex[j]).toString());
                    listvalues = listvalues + value + ",";
                }
                String values = listvalues.substring(0, listvalues.length() - 1);
                sqlQuery = "INSERT INTO " + table + "(" + fields + ")" +
                        " VALUES(" + values + ");";
                int count = 0;
                    try {
    //                    System.out.println(sqlQuery);
                        count = connection.ExecuteUpdate(sqlQuery);
                    } catch (SQLException ex) {
                        error.add("Ошибка в строке " + (i + 1) +
                                " : код-" + ex.getErrorCode() + "\n\r" +
                                ex.getMessage() + "\n\r");
                    }
                retval = retval + count;
                // определяем процент выполнения
                int percent = (int)(retval * 100) / rowCount;
    //            System.out.println("percent = " + percent);
                OperateProgressBar.setValue(percent);
            }
            // проверяем наличие сообщений в массиве ошибок
            if(error.isEmpty()){
                // если массив ошибок пуст
                txtStep.setText("Ошибки не обнаружены");
            }else{
                String text = "";
                for(int i = 0; i < error.size(); i++)
                    text = text + error.get(i).toString();
                txtStep.setText(text);
            }
            OperateProgressBar.setVisible(false);
    //        setCursor(Cursor.getDefaultCursor());// возвращаем исходный вид курсора
            return retval;
        }

        /**
        * обновление данных в выбранной таблице базы данных
        */
        private int updateDataDB(){
            int retval = 0;
    //        ProgressDialog.setSize(370, 146);
    //        ProgressDialog.setLocation(getLocation().x, getLocation().y);
    //        ProgressDialog.setVisible(true);
            int rowCount = jTable1.getRowCount();

            // позиция разделителя в наименовании ключевого поля
            int pos = keyColumn.indexOf("-");

            // получаем наименования ключевых полей
            String tbKey = keyColumn.substring(0, pos);
            String targetKey= keyColumn.substring(pos + 1, keyColumn.length());

            // получаем индекс ключевого поля в таблице-источнике данных
            int Index = 0;
            for(int j = 0; j < jTable1.getColumnCount(); j++){
                if(targetKey.equals(jTable1.getColumnName(j))){
                    Index = j;
                    break;
                }
            }
            // перебираем строки в правом списке полей,
            // используя символ-разделитель "-", и заполняем ими соответствующие массивы
            int row = lstTargetList.getModel().getSize();// количество элементов
            String[] leftCols = new String[row];// список выбранных полей таблицы БД
            String[] rightCols = new String[row];// список импортируемых полей
            int[] colIndex = new int[row];// индекы столбцов таблицы
            ArrayList error = new ArrayList();// массив ошибочных записей
            // заполняем массивы полей
            for(int i = 0; i < row; i++){
                lstTargetList.setSelectedIndex(i);// выделяем элемент списка
                pos = lstTargetList.getSelectedValue().toString().indexOf("-");
                leftCols[i] = lstTargetList.getSelectedValue().toString().substring(0, pos);
                rightCols[i] = lstTargetList.getSelectedValue().toString().substring(pos + 1);
                // получаем индекс столбца по имени
                for(int j = 0; j < jTable1.getColumnCount(); j++){
                    if(rightCols[i].equals(jTable1.getColumnName(j))){
                        colIndex[i] = j;
    //                    System.out.println(colIndex[i]);
                        break;// прерываем цикл
                    }
                }
            }
            OperateProgressBar.setValue(0);
            String sqlQuery;// строка-запрос на добавление записи
            for(int i = 0; i < rowCount; i++){
                // получаем список значений для вставки
                String listvalues = "";
                for(int j = 0; j < colIndex.length; j++){
    //                System.out.println(colIndex[j]);
                    String value = connection.getCellValue(leftCols[j],
                            jTable1.getValueAt(i, colIndex[j]).toString());
                    listvalues = listvalues + leftCols[j] + "=" + value + ",";
                }
                // удаляем последний символ ","
                String values = listvalues.substring(0, listvalues.length() - 1);
                sqlQuery = "UPDATE " + table + " SET " + values + " WHERE " +
                        tbKey + "=" + connection.getCellValue(tbKey,
                            jTable1.getValueAt(i, Index).toString()) + ";";
                int count = 0;
                    try {
    //                    System.out.println(sqlQuery);
                        count = connection.ExecuteUpdate(sqlQuery);
                    } catch (SQLException ex) {
    //                    error.add("Ошиба в строке " + (i + 1) +
    //                            " : код-" + ex.getErrorCode() + "\n\r" +
    //                            ex.getMessage() + "\n\r");
    //                    setCursor(Cursor.getDefaultCursor());// возвращаем исходный вид курсора
                    }
                retval = retval + count;
                // определяем процент выполнения
                int percent = (int)(retval * 100) / rowCount;
    //            System.out.println("percent = " + percent);
                OperateProgressBar.setValue(percent);
            }
            // проверяем наличие сообщений в массиве ошибок
            if(error.isEmpty()){
                // если массив ошибок пуст
                txtStep.setText("Ошибки не обнаружены");
            }else{
                String text = "";
                for(int i = 0; i < error.size(); i++)
                    text = text + error.get(i).toString();
                txtStep.setText(text);
            }
            OperateProgressBar.setVisible(false);
            return retval;
        }

        /**
        * получение данных из выбранной таблицы базы данных
        */
        private void getDataFromDBTable(){
            // получаем перечень полей выбранной таблицы
            String fieldList = "";
            int row = lstTargetList.getModel().getSize();// количество элементов
            for(int i = 0; i < row; i++)
                fieldList = fieldList + 
                        lstTargetList.getModel().getElementAt(i).toString() + ",";
            // удаляем последний символ
            String fields = fieldList.substring(0, fieldList.length() - 1);
            // строка-запрос на выборку данных
            String sqlQuery = "SELECT " + fields + " FROM " + table + ";";
                try {
                    DBTableModel tModel = 
                            new DBTableModel(connection.ExecuteQuery(sqlQuery));
                    DefaultTableModel dtModel = 
                            new DefaultTableModel(tModel.getContent(), 
                            tModel.getColumnName());
                    // модель данных для таблицы
                    jTable1.setModel(dtModel);
                } catch (SQLException ex) {
                    Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE,
                            null, ex);
                }
        }


        private int exportDataFromDB(){
            int retval = 0;
    //        ProgressDialog.setSize(370, 146);
    //        ProgressDialog.setLocation(getLocation().x, getLocation().y);
    //        ProgressDialog.setVisible(true);
            int rowCount = jTable1.getRowCount();
            return retval;
        }

    }
    
    private class ConnectOptions{

        private String databaseName;
        private String hostIP;
        private String serverPort;
        private String username;
        private String Password;
        private String aliasName;
        private boolean accessOpen;// флаг открытия доступа к базе данных
        private File fileName;
        
        public ConnectOptions() {
            accessOpen = false;// доступ пока закрыт
        }

        /**
         * @return the databaseName
         */
        public String getDatabaseName() {
            return databaseName;
        }

        /**
         * @param databaseName the databaseName to set
         */
        public void setDatabaseName(String databaseName) {
            this.databaseName = databaseName;
        }

        /**
         * @return the hostIP
         */
        public String getHostIP() {
            return hostIP;
        }

        /**
         * @param hostIP the hostIP to set
         */
        public void setHostIP(String hostIP) {
            this.hostIP = hostIP;
        }

        /**
         * @return the serverPort
         */
        public String getServerPort() {
            return serverPort;
        }

        /**
         * @param serverPort the serverPort to set
         */
        public void setServerPort(String serverPort) {
            this.serverPort = serverPort;
        }

        /**
         * @return the username
         */
        public String getUsername() {
            return username;
        }

        /**
         * @param username the username to set
         */
        public void setUsername(String username) {
            this.username = username;
        }

        /**
         * @return the Password
         */
        public String getPassword() {
            return Password;
        }

        /**
         * @param Password the Password to set
         */
        public void setPassword(String Password) {
            this.Password = Password;
        }

        /**
         * @return the accessOpen
         */
        public boolean isAccessOpen() {
            return accessOpen;
        }

        /**
         * @param accessOpen the accessOpen to set
         */
        public void setAccessOpen(boolean accessOpen) {
            this.accessOpen = accessOpen;
        }
        
        /**
         * отображает окно доступа для подключения к базе данных
         */
        public void showLoginframe(){
            LoginFrame logframe = new LoginFrame();// создаём экземпляр формы
            // если задан файл свойств, то считываем его и задаём параметры соединения для формы доступа
            if(fileName != null) {
                try {
                    readConnectProperties();
                } catch (IOException ex) {
                    Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
                logframe.setDatabaseName(databaseName);
                logframe.setHostIP(hostIP);
                logframe.setServerPort(serverPort);
                logframe.setUserName(username);
            }
            logframe.showDialog(OperateFrame.this);// показываем его
            if(logframe.isOk()) {
                hostIP = logframe.getHostIP();
                serverPort = logframe.getServerPort();
                databaseName = logframe.getDatabaseName();
                username = logframe.getUserName();
                Password = logframe.getPassword();
                aliasName = logframe.getAliasName();
            } else {
                databaseName = "";
            }
        }

        /**
         * @return the aliasName
         */
        public String getAliasName() {
            return aliasName;
        }

        /**
         * @param aliasName the aliasName to set
         */
        public void setAliasName(String aliasName) {
            this.aliasName = aliasName;
        }

        /**
         * @return the fileName
         */
        public File getFileName() {
            return fileName;
        }

        /**
         * @param fileName the fileName to set
         */
        public void setFileName(File fileName) {
            this.fileName = fileName;
        }
        
        private void readConnectProperties() throws IOException {
            Properties props = new Properties();// создаём класс для чтения из файла свойств
            try {
                // создаём поток чтения данных из файла
                FileInputStream fin = new FileInputStream(fileName);
                props.load(fin);// считываем свойства

                // получаем все перечисенные свойства
                Enumeration e = props.propertyNames();
                while(e.hasMoreElements()) {
                    String propName = e.nextElement().toString();// получаем имя свойства
                    System.out.println(propName.toLowerCase() + "=" + props.getProperty(propName));
                    // проверяем, что содержится в имени свойства
                    if(propName.toLowerCase().contains("database")) {
                        databaseName = props.getProperty(propName);
                    } else if(propName.toLowerCase().contains("hostip")) {
                        hostIP = props.getProperty(propName);
                    } else if(propName.toLowerCase().contains("serverport")) {
                        serverPort = props.getProperty(propName);
                    } else if(propName.toLowerCase().contains("user")) {
                        username = props.getProperty(propName);
                    }
                }
            } catch (FileNotFoundException ex) {
                Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }
    
    private boolean openConnection(File file) throws FileNotFoundException, 
            IOException, SQLException, ClassNotFoundException {
        // открываем соединение с базой данных
        //читаем файл свойств для загрузки драйвера и других параметров
//        Properties props= new Properties();
        String message = "Connection is not opened!";
        boolean retval;
        // создаём класс для получения доступа к базе данных
        if(connOptions == null) connOptions = new ConnectOptions();
        connOptions.setFileName(file);
        connOptions.showLoginframe();
        if(!connOptions.getDatabaseName().equals("")) {
            try {
                // set drivername
                String driver = "org.firebirdsql.jdbc.FBDriver";
                String url = "jdbc:firebirdsql://" + connOptions.getHostIP() + ":" +
                    connOptions.getServerPort() + "/" + 
                    connOptions.getDatabaseName();

                // открываем первоначальное соединение с базой данных
                connection = new JDBCConnection(driver, url, connOptions.getUsername(),
                        connOptions.getPassword());
                if (connection.isClosedConn() != true){
                    message = "Connection is opening!";
                    retval = true;
                } else{
                    retval = false;
    //                System.exit(0);
                }
                System.out.println("retval=" + retval);
                // окно сообщения по результатам соединения
                getInformDialog(this, message, InformDialog.InformType.CONNECT);
                return retval;
            } catch (SQLException | ClassNotFoundException ex){
                // окно сообщения по результатам соединения
                getInformDialog(this, message, InformDialog.InformType.CONNECT);
                return false;
            }
        } else {return false;}
            
    }
    
    private void closeConnection(){
        try {
            if (connection != null && !connection.isClosedConn()) {
            JDBCConnection.getConn().close();
            if(connection.isClosedConn()){
                connection = null;
                
            }
            }
        } catch (SQLException ex) {
            Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    private void getInformDialog(JFrame owner, String message, InformDialog.InformType type){
        InformDialog idialog;
        if(owner != null){
            idialog = new InformDialog(owner);
        } else {
            idialog = new InformDialog();
        }
        idialog.setMessage(message);
        idialog.setType(type);
        idialog.setVisible(true);
    }
    
    /**
     * Читает свойства соединения из выбранного файла свойств
     * @param filename имя файла свойств для чтения
     */
    private void readConnectProperies(java.io.File filename) throws IOException {
        Properties props = new Properties();// создаём класс для чтения из файла свойств
        try {
            LoginFrame logFrame = new LoginFrame();// окно ввода параметров соединения
            
            // создаём поток чтения данных из файла
            FileInputStream fin = new FileInputStream(filename);
            props.load(fin);// считываем свойства
            
            // получаем все перечисенные свойства
            Enumeration e = props.propertyNames();
            while(e.hasMoreElements()) {
                String propName = e.nextElement().toString();// получаем имя свойства
                System.out.println(propName.toLowerCase() + "=" + props.getProperty(propName));
                // проверяем, что содержится в имени свойства
                if(propName.toLowerCase().contains("database")) {
                    logFrame.setDatabaseName(props.getProperty(propName));
                } else if(propName.toLowerCase().contains("hostip")) {
                    logFrame.setHostIP(props.getProperty(propName));
                } else if(propName.toLowerCase().contains("serverport")) {
                    logFrame.setServerPort(props.getProperty(propName));
                } else if(propName.toLowerCase().contains("user")) {
                    logFrame.setUserName(props.getProperty(propName));
                }
            }
            
            // выводим на экран окно для ввода пароля
            logFrame.showDialog(this);
        } catch (FileNotFoundException ex) {
            Logger.getLogger(OperateFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
}
